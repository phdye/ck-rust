# Module: ck_cc

## Overview

The ck_cc module provides a compiler compatibility abstraction layer that enables CK to work across different compilers (GCC, Clang, Sun Studio) while leveraging compiler-specific optimizations and builtins when available. It abstracts compiler attributes, branch prediction hints, bitwise operations, and memory layout directives.

## Dependencies

This module has no dependencies on other CK modules. It is the foundational layer upon which all other modules are built.

| Dependency | Type | Purpose |
|------------|------|---------|
| ck_md.h | External (generated) | Platform metadata (cache line size) - generated by configure |
| C99 compiler | External | Standard C99 language features |

## Data Structures

This module defines no runtime data structures. It provides only compile-time macros and inline functions.

## Algorithms

### ck_cc_ffs

**Purpose:** Find first set bit (1-indexed position of least significant set bit)

**Signature:**
```
ck_cc_ffs(v: 32-bit unsigned integer) → 32-bit signed integer
```

**Algorithm:**
1. IF v equals 0: return 0
2. Initialize position i to 1
3. WHILE least significant bit of v is 0:
   - Increment i
   - Right-shift v by 1
4. Return i

**Complexity:**
- Time: O(log n) where n is the bit width (worst case scans all bits)
- Space: O(1)

**Correctness Reference:** Implementation-derived; matches POSIX ffs() semantics

**Note:** When compiler builtins are available (GCC/Clang), uses `__builtin_ffsl` for O(1) hardware instruction.

### ck_cc_ffsl

**Purpose:** Find first set bit in long integer

**Signature:**
```
ck_cc_ffsl(v: unsigned long) → 32-bit signed integer
```

**Algorithm:** Same as ck_cc_ffs but operates on unsigned long (typically 64-bit).

**Complexity:**
- Time: O(log n)
- Space: O(1)

**Correctness Reference:** Implementation-derived; matches POSIX ffsl() semantics

### ck_cc_ffsll

**Purpose:** Find first set bit in long long integer

**Signature:**
```
ck_cc_ffsll(v: unsigned long long) → 32-bit signed integer
```

**Algorithm:** Same as ck_cc_ffs but operates on unsigned long long (64-bit).

**Complexity:**
- Time: O(log n)
- Space: O(1)

**Correctness Reference:** Implementation-derived; matches ffsll() semantics

### ck_cc_ctz

**Purpose:** Count trailing zeros (number of zero bits following least significant set bit)

**Signature:**
```
ck_cc_ctz(x: 32-bit unsigned integer) → 32-bit signed integer
```

**Algorithm:**
1. IF x equals 0: return 0 (note: undefined in some implementations)
2. Initialize count i to 0
3. WHILE least significant bit of x is 0:
   - Increment i
   - Right-shift x by 1
4. Return i

**Complexity:**
- Time: O(log n)
- Space: O(1)

**Correctness Reference:** Implementation-derived

**Note:** When compiler builtins are available, uses `__builtin_ctz` for O(1) hardware instruction.

### ck_cc_popcount

**Purpose:** Count number of set bits (population count / Hamming weight)

**Signature:**
```
ck_cc_popcount(x: 32-bit unsigned integer) → 32-bit signed integer
```

**Algorithm:**
1. Initialize accumulator acc to 0
2. WHILE x is not 0:
   - Add (x AND 1) to acc
   - Right-shift x by 1
3. Return acc

**Complexity:**
- Time: O(log n)
- Space: O(1)

**Correctness Reference:** Implementation-derived

**Note:** When compiler builtins are available, uses `__builtin_popcount` for O(1) hardware instruction.

## Concurrency

This module is not thread-safe and does not require thread safety. All operations are either:
- Compile-time macros with no runtime state
- Pure functions with no side effects

No synchronization is required.

## Platform Considerations

### GCC/Clang (include/gcc/ck_cc.h)
- Uses `__attribute__` for alignment, packing, and optimization hints
- Uses `__builtin_*` functions for efficient bit operations
- Uses `__builtin_expect` for branch prediction
- Uses `__builtin_offsetof` for struct member offset calculation
- Uses `__restrict__` for pointer aliasing hints

### Sun Studio
- Limited attribute support (unused, used, imm disabled)
- Falls back to portable implementations

### Generic (include/ck_cc.h)
- Provides portable fallback implementations
- No compiler-specific optimizations
- Uses manual bit scanning loops

## Macros Reference

| Macro | Purpose | GCC Implementation |
|-------|---------|-------------------|
| CK_CC_INLINE | Inline function hint | `inline` with `__attribute__((unused))` |
| CK_CC_FORCE_INLINE | Force inlining | `__attribute__((always_inline)) inline` |
| CK_CC_RESTRICT | Pointer non-aliasing hint | `__restrict__` |
| CK_CC_PACKED | Remove struct padding | `__attribute__((packed))` |
| CK_CC_ALIGN(B) | Align to B bytes | `__attribute__((aligned(B)))` |
| CK_CC_CACHELINE | Align to cache line | `CK_CC_ALIGN(CK_MD_CACHELINE)` |
| CK_CC_LIKELY(x) | Branch likely taken | `__builtin_expect(!!(x), 1)` |
| CK_CC_UNLIKELY(x) | Branch unlikely taken | `__builtin_expect(!!(x), 0)` |
| CK_CC_UNUSED | Suppress unused warnings | `__attribute__((unused))` |
| CK_CC_USED | Prevent dead code elimination | `__attribute__((used))` |
| CK_CC_ALIASED | Allow type aliasing | `__attribute__((__may_alias__))` |
| CK_CC_TYPEOF(X, D) | Compile-time type inference | `__typeof__(X)` |
| CK_CC_CONTAINER | Container-of macro | Generates function to get container from member |
| CK_CC_PAD(x) | Anonymous padding union | `union { char pad[x]; }` |
| CK_CC_DECONST_PTR | Remove const qualifier | Cast through uintptr_t |
| CK_CC_WEAKREF | Weak reference | `__attribute__((weakref))` |
| CK_CPP_CAST | C++ compatible cast | `static_cast<type>(arg)` in C++, identity in C |
